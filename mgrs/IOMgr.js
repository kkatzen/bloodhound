const connectToStores = require("alt-utils/lib/connectToStores");
const SessionStore = require("../alt/stores/SessionStore.js");
const SessionActions = require("../alt/actions/SessionActions.js");
const EventActions = require("../alt/actions/EventActions.js");

/**
 * Class that knows how to interact with the store for the logged-in user.
 */
class IOMgr {
  constructor() {
    this.events = {};
    this.user = null;
    console.log("IOMgr constructor....", SessionStore);
    SessionStore.listen(state => this._onChange());
  }

  loadMore() {
    const uid = this._getUser().uid;
    const limit = prompt("How many to load?");
    const lastItem = SessionStore.state.lastItemLoaded;
    console.log("attempting read from " + lastItem);
    const myEventsRef = firebase
      .database()
      .ref("events/" + uid + "")
      .orderByKey()
      .limitToLast(parseInt(limit) + 1)
      .endAt(lastItem)
      .once("value")
      .then(snapshot => this._processSnapshot(snapshot));
  }

  writeEvent(event) {
    const timestamp = new Date().getTime();
    this.storeEvent(timestamp, event);
  }

  storeEvent(timestamp, event) {
    const user = this._getUser();
    console.log("STORING EVENT FOR: " + user.email);


console.log('event');
console.log(event);
console.log(Object.keys(event).includes("dataURL"));
console.log(Object.keys(event));
    if (Object.keys(event).includes("dataURL")) {
      console.log("EVENT DATA HAS DATAURL")
      // Generate a reference to a new location and add some data using push()
      var newImageRef = firebase
        .database()
        .ref("images/" + user.uid)
        .push();

      // Get the unique key generated by push()
      var refId = newImageRef.key;
      firebase
        .database()
        .ref("images/" + user.uid + "/" + refId)
        .set(event["dataURL"]);

      delete event['dataURL'];
      event["imageRefId"] = refId;
    }

    // These should be written in batches
    firebase
      .database()
      .ref("events/" + user.uid + "/" + timestamp)
      .set(event);


    // TODO: Maybe don't dispatch this locally.
    // Listen to DB changes and update UI when change is commited.
    EventActions.addEvent(timestamp, event);

    console.log("EVENTS UPDATED.");
  }

  deleteEvent(timestamp) {

    // TODO(kristak) clean up dead image references

    console.log("xxdelete");
    // TODO: Maybe don't dispatch this locally.
    // Listen to DB changes and update UI when change is commited.
    EventActions.deleteEvent(timestamp);

    firebase
      .database()
      .ref("events/" + this.user.uid + "/" + timestamp)
      .remove();
  }

  setComponentConfig(newValue) {
    try {
      JSON.parse(newValue);
      firebase
        .database()
        .ref("configs/" + SessionStore.state.user.uid)
        .set(newValue);
      SessionActions.setComponentConfig(newValue);
    } catch (err) {
      alert("INVALID JSON: " + err.message);
    }
  }

  _onChange(state) {
    console.log("_onChange");
    if (this.user != SessionStore.state.user) {
      this._onUserChange();
    }
  }

  _onUserChange(state) {
    console.log("_onUserChange");
    this.user = SessionStore.state.user;
    if (this.user != null) {
      this._getInitialData();
    } else {
      SessionActions.setComponentConfig.defer(null);
    }
  }

  _processSnapshot(snapshot) {
    const events = this.events;
    let updateLastItemRetrieved = false;
    snapshot.forEach(function(childSnapshot) {
      if (updateLastItemRetrieved == false) {
        updateLastItemRetrieved = true;

        // We need the defer here because we cannot dispatch an new
        // action while the previous one is still being processed.
        SessionActions.setLastItemLoaded.defer(childSnapshot.key);
      }
      EventActions.addEvent(childSnapshot.key, childSnapshot.val());
    });
  }

  _getUser() {
    return this.user;
  }

  _getLastItemLoaded() {
    return SessionStore.state.lastItemLoaded;
  }

  _getInitialData() {
    console.log("_getInitialData");
    if (!SessionStore.state.componentConfig) {
      const configRef = firebase
        .database()
        .ref("configs/" + this.user.uid + "");
      configRef.on("value", snapshot => this._processConfigSnapshot(snapshot));
    }

    const myEventsRef = firebase
      .database()
      .ref("events/" + this.user.uid + "")
      .limitToLast(5)
      .once("value")
      .then(snapshot => this._processSnapshot(snapshot));
  }

  _processConfigSnapshot(snapshot) {
    console.log("_processConfigSnapshot snapshot", snapshot);
    // We need the defer here because we cannot dispatch a new
    // action while the previous one is still being processed.
    console.log(snapshot.val());
    if (snapshot.val()) {
      SessionActions.setComponentConfig.defer(JSON.parse(snapshot.val()));
    } else {
      SessionActions.setComponentConfig.defer(null);
    }
  }
}

module.exports = IOMgr;
